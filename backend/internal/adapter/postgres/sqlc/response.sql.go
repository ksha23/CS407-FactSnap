// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: response.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createResponse = `-- name: CreateResponse :one
WITH new_response AS (
    INSERT INTO responses (question_id, author_id, body, image_urls)
    VALUES($1, $2, $3, $4)
    RETURNING id, author_id, question_id, body, image_urls, created_at, edited_at
)
SELECT
    nr.id, nr.author_id, nr.question_id, nr.body, nr.image_urls, nr.created_at, nr.edited_at,
    u.id, u.username, u.email, u.display_name, u.role, u.about_me, u.avatar_url, u.created_at,
    TRUE AS is_owned
FROM
    new_response nr
    JOIN users u ON nr.author_id = u.id
`

type CreateResponseRow struct {
	ID         uuid.UUID
	AuthorID   string
	QuestionID uuid.UUID
	Body       string
	ImageUrls  []string
	CreatedAt  time.Time
	EditedAt   time.Time
	User       User
	IsOwned    bool
}

func (q *Queries) CreateResponse(ctx context.Context, questionID uuid.UUID, authorID string, body string, imageUrls []string) (CreateResponseRow, error) {
	row := q.db.QueryRow(ctx, createResponse,
		questionID,
		authorID,
		body,
		imageUrls,
	)
	var i CreateResponseRow
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.QuestionID,
		&i.Body,
		&i.ImageUrls,
		&i.CreatedAt,
		&i.EditedAt,
		&i.User.ID,
		&i.User.Username,
		&i.User.Email,
		&i.User.DisplayName,
		&i.User.Role,
		&i.User.AboutMe,
		&i.User.AvatarUrl,
		&i.User.CreatedAt,
		&i.IsOwned,
	)
	return i, err
}

const deleteResponse = `-- name: DeleteResponse :exec
DELETE FROM responses WHERE id = $1
`

func (q *Queries) DeleteResponse(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteResponse, id)
	return err
}

const editResponse = `-- name: EditResponse :one
WITH edited_response AS (
    UPDATE responses
    SET
        body = $1,
        edited_at = current_timestamp
    WHERE responses.id = $2
    RETURNING id, author_id, question_id, body, image_urls, created_at, edited_at
)
SELECT
    er.id, er.author_id, er.question_id, er.body, er.image_urls, er.created_at, er.edited_at,
    u.id, u.username, u.email, u.display_name, u.role, u.about_me, u.avatar_url, u.created_at,
    TRUE AS is_owned
FROM
    edited_response er
    JOIN users u ON er.author_id = u.id
`

type EditResponseRow struct {
	ID         uuid.UUID
	AuthorID   string
	QuestionID uuid.UUID
	Body       string
	ImageUrls  []string
	CreatedAt  time.Time
	EditedAt   time.Time
	User       User
	IsOwned    bool
}

func (q *Queries) EditResponse(ctx context.Context, body string, iD uuid.UUID) (EditResponseRow, error) {
	row := q.db.QueryRow(ctx, editResponse, body, iD)
	var i EditResponseRow
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.QuestionID,
		&i.Body,
		&i.ImageUrls,
		&i.CreatedAt,
		&i.EditedAt,
		&i.User.ID,
		&i.User.Username,
		&i.User.Email,
		&i.User.DisplayName,
		&i.User.Role,
		&i.User.AboutMe,
		&i.User.AvatarUrl,
		&i.User.CreatedAt,
		&i.IsOwned,
	)
	return i, err
}

const getAllResponsesByQuestionID = `-- name: GetAllResponsesByQuestionID :many
SELECT
    r.id, r.author_id, r.question_id, r.body, r.image_urls, r.created_at, r.edited_at,
    u.id, u.username, u.email, u.display_name, u.role, u.about_me, u.avatar_url, u.created_at,
    r.author_id = $1 AS is_owned
FROM responses r
    JOIN users u ON u.id = r.author_id
WHERE r.question_id = $2
ORDER BY r.created_at DESC
`

type GetAllResponsesByQuestionIDRow struct {
	Response Response
	User     User
	IsOwned  bool
}

func (q *Queries) GetAllResponsesByQuestionID(ctx context.Context, userID string, iD uuid.UUID) ([]GetAllResponsesByQuestionIDRow, error) {
	rows, err := q.db.Query(ctx, getAllResponsesByQuestionID, userID, iD)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllResponsesByQuestionIDRow{}
	for rows.Next() {
		var i GetAllResponsesByQuestionIDRow
		if err := rows.Scan(
			&i.Response.ID,
			&i.Response.AuthorID,
			&i.Response.QuestionID,
			&i.Response.Body,
			&i.Response.ImageUrls,
			&i.Response.CreatedAt,
			&i.Response.EditedAt,
			&i.User.ID,
			&i.User.Username,
			&i.User.Email,
			&i.User.DisplayName,
			&i.User.Role,
			&i.User.AboutMe,
			&i.User.AvatarUrl,
			&i.User.CreatedAt,
			&i.IsOwned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResponseByID = `-- name: GetResponseByID :one
SELECT
    r.id, r.author_id, r.question_id, r.body, r.image_urls, r.created_at, r.edited_at,
    u.id, u.username, u.email, u.display_name, u.role, u.about_me, u.avatar_url, u.created_at,
    r.author_id = $1 AS is_owned
FROM
    responses r
    JOIN users u ON u.id = r.author_id
WHERE
    r.id = $2
    LIMIT 1
`

type GetResponseByIDRow struct {
	Response Response
	User     User
	IsOwned  bool
}

func (q *Queries) GetResponseByID(ctx context.Context, userID string, iD uuid.UUID) (GetResponseByIDRow, error) {
	row := q.db.QueryRow(ctx, getResponseByID, userID, iD)
	var i GetResponseByIDRow
	err := row.Scan(
		&i.Response.ID,
		&i.Response.AuthorID,
		&i.Response.QuestionID,
		&i.Response.Body,
		&i.Response.ImageUrls,
		&i.Response.CreatedAt,
		&i.Response.EditedAt,
		&i.User.ID,
		&i.User.Username,
		&i.User.Email,
		&i.User.DisplayName,
		&i.User.Role,
		&i.User.AboutMe,
		&i.User.AvatarUrl,
		&i.User.CreatedAt,
		&i.IsOwned,
	)
	return i, err
}
