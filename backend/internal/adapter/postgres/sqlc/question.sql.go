// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: question.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createPoll = `-- name: CreatePoll :one
INSERT INTO polls (question_id)
VALUES ($1)
RETURNING id, question_id, created_at
`

func (q *Queries) CreatePoll(ctx context.Context, questionID uuid.UUID) (Poll, error) {
	row := q.db.QueryRow(ctx, createPoll, questionID)
	var i Poll
	err := row.Scan(&i.ID, &i.QuestionID, &i.CreatedAt)
	return i, err
}

type CreatePollOptionsParams struct {
	PollID uuid.UUID
	Label  string
	Index  int
}

const createPollVote = `-- name: CreatePollVote :exec
INSERT INTO poll_votes (poll_id, option_id, user_id)
VALUES ($1, $2, $3)
`

func (q *Queries) CreatePollVote(ctx context.Context, pollID uuid.UUID, optionID uuid.UUID, userID string) error {
	_, err := q.db.Exec(ctx, createPollVote, pollID, optionID, userID)
	return err
}

const createQuestion = `-- name: CreateQuestion :one
WITH new_question AS (
    INSERT INTO questions (
        author_id,
        content_type,
        title,
        body,
        category,
        location_id,
        image_urls,
        expired_at
    )
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    RETURNING id, author_id, content_type, title, body, location_id, image_urls, category, num_responses, created_at, edited_at, expired_at
)
SELECT
    nq.id, nq.author_id, nq.content_type, nq.title, nq.body, nq.location_id, nq.image_urls, nq.category, nq.num_responses, nq.created_at, nq.edited_at, nq.expired_at,
    l.id, l.location, l.name, l.address,
    u.id, u.username, u.email, u.display_name, u.role, u.about_me, u.avatar_url, u.created_at,
    TRUE AS is_owned
FROM
    new_question nq
    JOIN users u ON nq.author_id = u.id
    JOIN locations l ON nq.location_id = l.id
`

type CreateQuestionParams struct {
	AuthorID    string
	ContentType string
	Title       string
	Body        *string
	Category    string
	LocationID  uuid.UUID
	ImageUrls   []string
	ExpiredAt   time.Time
}

type CreateQuestionRow struct {
	ID           uuid.UUID
	AuthorID     string
	ContentType  string
	Title        string
	Body         *string
	LocationID   uuid.UUID
	ImageUrls    []string
	Category     string
	NumResponses int
	CreatedAt    time.Time
	EditedAt     time.Time
	ExpiredAt    time.Time
	Location     Location
	User         User
	IsOwned      bool
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (CreateQuestionRow, error) {
	row := q.db.QueryRow(ctx, createQuestion,
		arg.AuthorID,
		arg.ContentType,
		arg.Title,
		arg.Body,
		arg.Category,
		arg.LocationID,
		arg.ImageUrls,
		arg.ExpiredAt,
	)
	var i CreateQuestionRow
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.ContentType,
		&i.Title,
		&i.Body,
		&i.LocationID,
		&i.ImageUrls,
		&i.Category,
		&i.NumResponses,
		&i.CreatedAt,
		&i.EditedAt,
		&i.ExpiredAt,
		&i.Location.ID,
		&i.Location.Location,
		&i.Location.Name,
		&i.Location.Address,
		&i.User.ID,
		&i.User.Username,
		&i.User.Email,
		&i.User.DisplayName,
		&i.User.Role,
		&i.User.AboutMe,
		&i.User.AvatarUrl,
		&i.User.CreatedAt,
		&i.IsOwned,
	)
	return i, err
}

const decrementResponseAmount = `-- name: DecrementResponseAmount :exec
UPDATE questions
SET num_responses =
        CASE
            WHEN num_responses > 0
                THEN num_responses - $2
            ELSE 0
            END
WHERE id = $1
`

func (q *Queries) DecrementResponseAmount(ctx context.Context, iD uuid.UUID, numResponses int) error {
	_, err := q.db.Exec(ctx, decrementResponseAmount, iD, numResponses)
	return err
}

const deletePollVote = `-- name: DeletePollVote :exec
DELETE FROM poll_votes
WHERE user_id = $1 AND poll_id = $2
`

func (q *Queries) DeletePollVote(ctx context.Context, userID string, pollID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePollVote, userID, pollID)
	return err
}

const getPollByQuestionID = `-- name: GetPollByQuestionID :one
SELECT p.id, p.question_id, p.created_at
FROM polls p
WHERE p.question_id = $1
`

type GetPollByQuestionIDRow struct {
	Poll Poll
}

func (q *Queries) GetPollByQuestionID(ctx context.Context, questionID uuid.UUID) (GetPollByQuestionIDRow, error) {
	row := q.db.QueryRow(ctx, getPollByQuestionID, questionID)
	var i GetPollByQuestionIDRow
	err := row.Scan(&i.Poll.ID, &i.Poll.QuestionID, &i.Poll.CreatedAt)
	return i, err
}

const getPollOptions = `-- name: GetPollOptions :many
SELECT po.id, po.poll_id, po.label, po.index
FROM
    polls p
    JOIN poll_options po ON p.id = po.poll_id
WHERE p.id = $1
GROUP BY po.id
ORDER BY po.index
`

type GetPollOptionsRow struct {
	PollOption PollOption
}

func (q *Queries) GetPollOptions(ctx context.Context, id uuid.UUID) ([]GetPollOptionsRow, error) {
	rows, err := q.db.Query(ctx, getPollOptions, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPollOptionsRow{}
	for rows.Next() {
		var i GetPollOptionsRow
		if err := rows.Scan(
			&i.PollOption.ID,
			&i.PollOption.PollID,
			&i.PollOption.Label,
			&i.PollOption.Index,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPollVotes = `-- name: GetPollVotes :many
SELECT
    po.index,
    COUNT(pv.user_id)         AS num_votes,
    BOOL_OR(pv.user_id = $2)  AS is_selected
FROM poll_options po
    JOIN poll_votes pv ON pv.option_id = po.id
WHERE po.poll_id = $1
GROUP BY po.id
`

type GetPollVotesRow struct {
	Index      int
	NumVotes   int
	IsSelected bool
}

func (q *Queries) GetPollVotes(ctx context.Context, pollID uuid.UUID, userID string) ([]GetPollVotesRow, error) {
	rows, err := q.db.Query(ctx, getPollVotes, pollID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPollVotesRow{}
	for rows.Next() {
		var i GetPollVotesRow
		if err := rows.Scan(&i.Index, &i.NumVotes, &i.IsSelected); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionByID = `-- name: GetQuestionByID :one
SELECT
    q.id, q.author_id, q.content_type, q.title, q.body, q.location_id, q.image_urls, q.category, q.num_responses, q.created_at, q.edited_at, q.expired_at,
    u.id, u.username, u.email, u.display_name, u.role, u.about_me, u.avatar_url, u.created_at,
    l.id, l.location, l.name, l.address,
    q.author_id = $2 AS is_owned
FROM
    questions q
    JOIN users u ON q.author_id = u.id
    JOIN locations l ON q.location_id = l.id

WHERE
    q.id = $1
    LIMIT 1
`

type GetQuestionByIDRow struct {
	Question Question
	User     User
	Location Location
	IsOwned  bool
}

func (q *Queries) GetQuestionByID(ctx context.Context, iD uuid.UUID, authorID string) (GetQuestionByIDRow, error) {
	row := q.db.QueryRow(ctx, getQuestionByID, iD, authorID)
	var i GetQuestionByIDRow
	err := row.Scan(
		&i.Question.ID,
		&i.Question.AuthorID,
		&i.Question.ContentType,
		&i.Question.Title,
		&i.Question.Body,
		&i.Question.LocationID,
		&i.Question.ImageUrls,
		&i.Question.Category,
		&i.Question.NumResponses,
		&i.Question.CreatedAt,
		&i.Question.EditedAt,
		&i.Question.ExpiredAt,
		&i.User.ID,
		&i.User.Username,
		&i.User.Email,
		&i.User.DisplayName,
		&i.User.Role,
		&i.User.AboutMe,
		&i.User.AvatarUrl,
		&i.User.CreatedAt,
		&i.Location.ID,
		&i.Location.Location,
		&i.Location.Name,
		&i.Location.Address,
		&i.IsOwned,
	)
	return i, err
}

const getQuestionsInRadiusFeed = `-- name: GetQuestionsInRadiusFeed :many
SELECT
    q.id, q.author_id, q.content_type, q.title, q.body, q.location_id, q.image_urls, q.category, q.num_responses, q.created_at, q.edited_at, q.expired_at,
    l.id, l.location, l.name, l.address,
    u.id, u.username, u.email, u.display_name, u.role, u.about_me, u.avatar_url, u.created_at,
    q.author_id = $1 AS is_owned
FROM questions q
         JOIN users u ON q.author_id = u.id
         JOIN locations l ON q.location_id = l.id
WHERE ST_DWithin(
              l.location::geography,
              ST_SetSRID(
                      ST_MakePoint(
                              $2::float8,
                              $3::float8
                      ),
                      4326
              )::geography,
              $4::float8 * 1609.34
      )
ORDER BY q.created_at DESC
LIMIT $6 OFFSET $5
`

type GetQuestionsInRadiusFeedParams struct {
	UserID      string
	Longitude   float64
	Latitude    float64
	RadiusMiles float64
	OffsetNum   int32
	LimitNum    int32
}

type GetQuestionsInRadiusFeedRow struct {
	Question Question
	Location Location
	User     User
	IsOwned  bool
}

func (q *Queries) GetQuestionsInRadiusFeed(ctx context.Context, arg GetQuestionsInRadiusFeedParams) ([]GetQuestionsInRadiusFeedRow, error) {
	rows, err := q.db.Query(ctx, getQuestionsInRadiusFeed,
		arg.UserID,
		arg.Longitude,
		arg.Latitude,
		arg.RadiusMiles,
		arg.OffsetNum,
		arg.LimitNum,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetQuestionsInRadiusFeedRow{}
	for rows.Next() {
		var i GetQuestionsInRadiusFeedRow
		if err := rows.Scan(
			&i.Question.ID,
			&i.Question.AuthorID,
			&i.Question.ContentType,
			&i.Question.Title,
			&i.Question.Body,
			&i.Question.LocationID,
			&i.Question.ImageUrls,
			&i.Question.Category,
			&i.Question.NumResponses,
			&i.Question.CreatedAt,
			&i.Question.EditedAt,
			&i.Question.ExpiredAt,
			&i.Location.ID,
			&i.Location.Location,
			&i.Location.Name,
			&i.Location.Address,
			&i.User.ID,
			&i.User.Username,
			&i.User.Email,
			&i.User.DisplayName,
			&i.User.Role,
			&i.User.AboutMe,
			&i.User.AvatarUrl,
			&i.User.CreatedAt,
			&i.IsOwned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementResponseAmount = `-- name: IncrementResponseAmount :exec
UPDATE questions
SET num_responses = num_responses + 1
WHERE id = $1
`

func (q *Queries) IncrementResponseAmount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementResponseAmount, id)
	return err
}

const isPollExpired = `-- name: IsPollExpired :one
SELECT q.expired_at < now() AS is_expired
FROM
    polls p
    JOIN questions q ON q.id = p.question_id
WHERE p.id = $1
`

func (q *Queries) IsPollExpired(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isPollExpired, id)
	var is_expired bool
	err := row.Scan(&is_expired)
	return is_expired, err
}

const setQuestionContentType = `-- name: SetQuestionContentType :exec
UPDATE questions
SET content_type = $2
WHERE id = $1
`

func (q *Queries) SetQuestionContentType(ctx context.Context, iD uuid.UUID, contentType string) error {
	_, err := q.db.Exec(ctx, setQuestionContentType, iD, contentType)
	return err
}
