// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: question.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createPoll = `-- name: CreatePoll :one
INSERT INTO polls (question_id)
VALUES ($1)
RETURNING id, question_id, created_at
`

func (q *Queries) CreatePoll(ctx context.Context, questionID uuid.UUID) (Poll, error) {
	row := q.db.QueryRow(ctx, createPoll, questionID)
	var i Poll
	err := row.Scan(&i.ID, &i.QuestionID, &i.CreatedAt)
	return i, err
}

type CreatePollOptionsParams struct {
	PollID uuid.UUID
	Label  string
	Index  int
}

const createQuestion = `-- name: CreateQuestion :one
WITH new_question AS (
    INSERT INTO questions (
        author_id,
        content_type,
        title,
        body,
        category,
        location_id,
        image_urls,
        expired_at
    )
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    RETURNING id, author_id, content_type, title, body, location_id, image_urls, category, created_at, edited_at, expired_at
)
SELECT
    nq.id, nq.author_id, nq.content_type, nq.title, nq.body, nq.location_id, nq.image_urls, nq.category, nq.created_at, nq.edited_at, nq.expired_at,
    l.id, l.location, l.name, l.address,
    u.id, u.username, u.email, u.display_name, u.role, u.about_me, u.avatar_url, u.created_at,
    TRUE AS is_owned
FROM
    new_question nq
    JOIN users u ON nq.author_id = u.id
    JOIN locations l ON nq.location_id = l.id
`

type CreateQuestionParams struct {
	AuthorID    string
	ContentType string
	Title       string
	Body        *string
	Category    string
	LocationID  uuid.UUID
	ImageUrls   []string
	ExpiredAt   time.Time
}

type CreateQuestionRow struct {
	ID          uuid.UUID
	AuthorID    string
	ContentType string
	Title       string
	Body        *string
	LocationID  uuid.UUID
	ImageUrls   []string
	Category    string
	CreatedAt   time.Time
	EditedAt    time.Time
	ExpiredAt   time.Time
	Location    Location
	User        User
	IsOwned     bool
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (CreateQuestionRow, error) {
	row := q.db.QueryRow(ctx, createQuestion,
		arg.AuthorID,
		arg.ContentType,
		arg.Title,
		arg.Body,
		arg.Category,
		arg.LocationID,
		arg.ImageUrls,
		arg.ExpiredAt,
	)
	var i CreateQuestionRow
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.ContentType,
		&i.Title,
		&i.Body,
		&i.LocationID,
		&i.ImageUrls,
		&i.Category,
		&i.CreatedAt,
		&i.EditedAt,
		&i.ExpiredAt,
		&i.Location.ID,
		&i.Location.Location,
		&i.Location.Name,
		&i.Location.Address,
		&i.User.ID,
		&i.User.Username,
		&i.User.Email,
		&i.User.DisplayName,
		&i.User.Role,
		&i.User.AboutMe,
		&i.User.AvatarUrl,
		&i.User.CreatedAt,
		&i.IsOwned,
	)
	return i, err
}

const getPollByQuestionID = `-- name: GetPollByQuestionID :one
SELECT p.id, p.question_id, p.created_at
FROM polls p
WHERE p.question_id = $1
`

type GetPollByQuestionIDRow struct {
	Poll Poll
}

func (q *Queries) GetPollByQuestionID(ctx context.Context, questionID uuid.UUID) (GetPollByQuestionIDRow, error) {
	row := q.db.QueryRow(ctx, getPollByQuestionID, questionID)
	var i GetPollByQuestionIDRow
	err := row.Scan(&i.Poll.ID, &i.Poll.QuestionID, &i.Poll.CreatedAt)
	return i, err
}

const getPollOptions = `-- name: GetPollOptions :many
SELECT po.id, po.poll_id, po.label, po.index
FROM
    polls p
    JOIN poll_options po ON p.id = po.poll_id
WHERE p.id = $1
GROUP BY po.id
ORDER BY po.index
`

type GetPollOptionsRow struct {
	PollOption PollOption
}

func (q *Queries) GetPollOptions(ctx context.Context, id uuid.UUID) ([]GetPollOptionsRow, error) {
	rows, err := q.db.Query(ctx, getPollOptions, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPollOptionsRow{}
	for rows.Next() {
		var i GetPollOptionsRow
		if err := rows.Scan(
			&i.PollOption.ID,
			&i.PollOption.PollID,
			&i.PollOption.Label,
			&i.PollOption.Index,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPollVotes = `-- name: GetPollVotes :many
SELECT
    po.index,
    COUNT(pv.user_id)         AS num_votes,
    BOOL_OR(pv.user_id = $2)  AS is_selected
FROM poll_options po
    JOIN poll_votes pv ON pv.option_id = po.id
WHERE po.poll_id = $1
GROUP BY po.id
`

type GetPollVotesRow struct {
	Index      int
	NumVotes   int
	IsSelected bool
}

func (q *Queries) GetPollVotes(ctx context.Context, pollID uuid.UUID, userID string) ([]GetPollVotesRow, error) {
	rows, err := q.db.Query(ctx, getPollVotes, pollID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPollVotesRow{}
	for rows.Next() {
		var i GetPollVotesRow
		if err := rows.Scan(&i.Index, &i.NumVotes, &i.IsSelected); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionByID = `-- name: GetQuestionByID :one
SELECT
    q.id, q.author_id, q.content_type, q.title, q.body, q.location_id, q.image_urls, q.category, q.created_at, q.edited_at, q.expired_at,
    u.id, u.username, u.email, u.display_name, u.role, u.about_me, u.avatar_url, u.created_at,
    l.id, l.location, l.name, l.address,
    q.author_id = $2 AS is_owned
FROM
    questions q
    JOIN users u ON q.author_id = u.id
    JOIN locations l ON q.location_id = l.id

WHERE
    q.id = $1
    LIMIT 1
`

type GetQuestionByIDRow struct {
	Question Question
	User     User
	Location Location
	IsOwned  bool
}

func (q *Queries) GetQuestionByID(ctx context.Context, iD uuid.UUID, authorID string) (GetQuestionByIDRow, error) {
	row := q.db.QueryRow(ctx, getQuestionByID, iD, authorID)
	var i GetQuestionByIDRow
	err := row.Scan(
		&i.Question.ID,
		&i.Question.AuthorID,
		&i.Question.ContentType,
		&i.Question.Title,
		&i.Question.Body,
		&i.Question.LocationID,
		&i.Question.ImageUrls,
		&i.Question.Category,
		&i.Question.CreatedAt,
		&i.Question.EditedAt,
		&i.Question.ExpiredAt,
		&i.User.ID,
		&i.User.Username,
		&i.User.Email,
		&i.User.DisplayName,
		&i.User.Role,
		&i.User.AboutMe,
		&i.User.AvatarUrl,
		&i.User.CreatedAt,
		&i.Location.ID,
		&i.Location.Location,
		&i.Location.Name,
		&i.Location.Address,
		&i.IsOwned,
	)
	return i, err
}

const setQuestionContentType = `-- name: SetQuestionContentType :exec
UPDATE questions
SET content_type = $2
WHERE id = $1
`

func (q *Queries) SetQuestionContentType(ctx context.Context, iD uuid.UUID, contentType string) error {
	_, err := q.db.Exec(ctx, setQuestionContentType, iD, contentType)
	return err
}
